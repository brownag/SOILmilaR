---
title: "Synthetic Transects"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{synthetic-transects}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(SOILmilaR)

data("loamy", package = "SOILmilaR")
```


The object `loamy` is a sample data set representing 3 "synthetic transects". 

We assume a similar "soil forming function" for these transects across each hypothetical "delineation" being transected. 
Here the values have been customized so that taxonomic particle size class is fine-loamy, but coarser textured in higher fragment material. Soil depth varies from shallow to very deep, uniform but centered around moderately deep. `pscs_*` quantities provided for example numeric quantities that can be used.

Next we define some rating functions for particle size class and depth class.

```{r}
rate_taxpartsize <- function(x) {
  dplyr::case_match(x,
                    c("sandy-skeletal") ~ 1,
                    c("sandy") ~ 3,
                    c("loamy", "coarse-loamy", "coarse-silty") ~ 5,
                    c("fine-loamy", "fine-silty") ~ 7,
                    c("clayey", "fine") ~ 9,
                    c("very-fine") ~ 11,
                    c("loamy-skeletal", "clayey-skeletal") ~ 13,
                    "fragmental" ~ 15)
}

rate_depthclass <- function(x,
                            breaks = c(
                              `very shallow` = 25,
                              `shallow` = 50,
                              `moderately deep` = 100,
                              `deep` = 150,
                              `very deep` = 1e4
                            ),
                            ...) {
  res <- cut(x, c(0, breaks))
  factor(res, levels = levels(res), labels = names(breaks))
}
```

The above rating functions can be combined in a list (`m`) which will be use used as the `mapping` argument to `similar_soils()`. The `similar_soils()` function applies the rating functions to the columns of the  input data `x`. Target column names in the data match the names of `m`, providing the "mapping" of data to rating functions.

Now we will demonstrate iterative filtering and application of similar soils criteria. 

```{r}
m <- list(taxpartsize = rate_taxpartsize,
          depth =  rate_depthclass)
x <- loamy
res0 <- similar_soils(x, m)
res0
```

Identifying soils similar to `"13.3"` (moderately deep, skeletal), corresponds to a major, dominant, component in a map unit. 

We might consider selecting a different reference condition manually after inspection. If we were to do that we could set, for example, `condition="7.4"` to compare against condition `"7.4"` rather than `"13.3"` that was automatically selected in this example.

Next, let's take the remaining dissimilar soils, and re-apply the similarity criteria based on the next-most-dominant condition. 

```{r}
y <- subset(x, !res0$similar, select = c("id", "taxpartsize", "depth"))

res1 <- similar_soils(y, m)
res1
```

At this second step, `"5.4"` (coarse-loamy, deep) is the dominant condition, also identified as similar are `"5.3"` (loamy, moderately deep)

One might consider which one of these is the best representative condition for the map unit (including unobserved areas) regardless of what is "dominant" in the observation data.

If there are issues with dissimilar soils being included in the same groups, consider revising the rating functions to ensure dissimilar properties have a distance greater than the set threshold (`thresh_single`). With `similar_soils()`, you can specify an alternate `condition` to compare against, or a `thresh_single` value higher or lower than `2`. 

```{r}
z <- subset(x, !x$id %in% c(res0$id[res0$similar], res1$id[res1$similar]),
            select = c("id", "taxpartsize", "depth"))
res2 <- similar_soils(z, m)
res2
```
 
Applying the similar soils criteria again, we find `"7.4"` is next most dominant, and `"7.3"` is similar to it.

We are left with a few soils that are not similar to any of the prior 3 sets:

```{r}
subset(res2, !similar)
```

We see that all 3 of the remaining soils are `"5.2"` (loamy, shallow).

Let's construct a data.frame, with the 4 groups of similar soils each identified with a greek letter. We will see which is the most prevalent overall based on the whole data set. We could also assess prevalence within individual transects.

```{r}
fin <- do.call('rbind', list(
  data.frame(component = greekletters[[1]][1], subset(res0, similar)),
  data.frame(component = greekletters[[1]][2], subset(res1, similar)),
  data.frame(component = greekletters[[1]][3], subset(res2, similar)),
  data.frame(component = greekletters[[1]][4], subset(res2, !similar))
))

# label any unassigned observations
una <- subset(res0, !res0$id %in% fin$id)
if (nrow(una) > 0) {
  fin <- rbind(fin, data.frame(component = "unassigned", una))
}

# put in original order of dataset
fin <- fin[match(x$id, fin$id), ]
```

We can tabulate the assignments we made and see how that corresponds with our concept for the relative abundance of the soils on the landscape in the typical delineation.

```{r}
res <- sort(prop.table(table(fin$component)), decreasing = TRUE)
res
```

In this case, we see Alpha, Beta and Gamma as major components, and Delta as a lesser component. However, Delta is dissimilar (and shallow, which is likely strongly contrasting) compared to all of the prior soils, so  if we accept the observation proportions as map unit component percentages we would have a four major component map unit.

It may be that there are other miscellaneous areas, or more-rarely-observed, unique, contrasting soils that were not captured as distinct by the rating functions. These could be split off either by creating a rating to capture them, or just noting their presence as minor components.

```{r}
# TODO: abstract this concept
cmp <- subset(fin, component == names(res[1]))
ref <- names(tail(sort(table(
  interaction(cmp$taxpartsize, cmp$depth)
)), 1))
fin_sim <- similar_soils(x, m, ref)

# transfer similarity distance and similar ranking
fin$similar_dist <- fin_sim$similar_dist
fin$similar <- fin_sim$similar # similarity to the dominant condition within Beta

# original sort order
fin
```

```{r, echo=FALSE}
# sort based on distance from dominant condition
knitr::kable(fin[order(fin$similar_dist),])
```

This process of iteratively and grouping soils into similarity groups can be automated using the `design_mapunit()` function.
